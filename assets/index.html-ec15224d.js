import{_ as i,r as s,o as t,c as l,a as n,b as e,d as a,e as c}from"./app-1bbcc8ed.js";const u="/blog-website/assets/2023-11-17-16-46-59-86d8bef4.png",r="/blog-website/assets/2023-11-17-17-04-43-479f0b9f.png",d="/blog-website/assets/2023-11-17-17-17-28-3c1e0631.png",k="/blog-website/assets/2023-11-18-09-36-54-417a28f2.png",v="/blog-website/assets/2023-11-18-10-41-17-bd3326c3.png",m="/blog-website/assets/2023-11-18-11-14-29-a259750a.png",b="/blog-website/assets/2023-11-18-13-08-14-6654da1d.png",g="/blog-website/assets/2023-11-18-14-02-41-b91458f2.png",f="/blog-website/assets/2023-11-18-14-04-33-23fd5c56.png",h="/blog-website/assets/2023-11-18-14-06-00-9f1d747e.png",w="/blog-website/assets/2023-11-18-14-08-32-c79f9a40.png",_="/blog-website/assets/2023-11-18-14-10-08-3e6b8862.png",x={},y=c(`<h1 id="javascript-代码的执行原理-✨" tabindex="-1"><a class="header-anchor" href="#javascript-代码的执行原理-✨" aria-hidden="true">#</a> JavaScript 代码的执行原理 ✨</h1><p>学习 JavaScript 代码的执行原理，有助于更深入地理解 JavaScript 语言的运作方式。在这个过程中，我们将深入探讨全局对象、执行上下文、变量对象等概念，以及函数的执行过程。</p><h2 id="代码是如何被执行的" tabindex="-1"><a class="header-anchor" href="#代码是如何被执行的" aria-hidden="true">#</a> 代码是如何被执行的</h2><p>首先，我们来看一小段 JavaScript 代码，后续的讨论将围绕这段代码展开：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Foo message&#39;</span>
  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token keyword">var</span> height <span class="token operator">=</span> <span class="token number">180</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="初始化全局对象-global-object" tabindex="-1"><a class="header-anchor" href="#初始化全局对象-global-object" aria-hidden="true">#</a> 初始化全局对象（Global Object）</h2><p>在执行 JavaScript 代码之前，引擎会在堆内存中创建一个全局对象（Global Object，简称 GO）。在浏览器环境中，全局对象就是 window 对象。</p><p>全局对象的特点包括：</p><ul><li>所有的作用域都可以访问到它</li><li>包含一些内置的属性和方法，如 Math、String、Date、parseInt</li><li>宿主环境可以为全局对象添加自定义的属性和方法，比如浏览器中的 window 属性</li></ul><p><img src="`+u+'" alt="堆内存中的全局对象"></p><h2 id="执行上下文-execution-context" tabindex="-1"><a class="header-anchor" href="#执行上下文-execution-context" aria-hidden="true">#</a> 执行上下文（Execution Context）</h2><p>JavaScript 引擎管理着一个执行上下文栈（Execution Context Stack，简称 ECS），也叫做代码的调用栈。在执行一段代码之前，引擎会创建相应的执行上下文，并将其压入执行上下文栈的栈顶。</p><p>全局代码执行时，会创建全局执行上下文（Global Execution Context），并将其压入执行上下文栈的栈顶。</p><p>在这个过程中，引擎会：</p><ol><li>进行变量提升（Hoisting），将变量和函数声明提前加入全局对象</li><li>初始化作用域链（Scope Chain），包含了全局对象</li><li>使用全局对象作为变量对象，并将全局范围内声明的变量和函数添加到变量对象中</li><li>将 this 关键字指向全局对象</li></ol><p><img src="'+r+'" alt="执行全局代码之前"></p><p>变量被添加到变量对象中，但尚未赋值；而函数则被提前创建为函数对象。</p><h2 id="变量对象-variable-object" tabindex="-1"><a class="header-anchor" href="#变量对象-variable-object" aria-hidden="true">#</a> 变量对象（Variable Object）</h2><p>每个执行上下文关联一个变量对象（Variable Object，简称 VO）。在执行上下文中声明的变量和函数都作为属性添加到变量对象中。</p><p>调用函数时，会为函数创建新的执行上下文，其变量对象称为活动对象（Activation Object，简称 AO）。AO 包含了函数参数，并作为函数执行上下文的变量对象存放声明的变量和函数。</p><p>变量对象提供一个容器，用于存储和检索当前执行上下文中定义的变量和函数。</p><h2 id="执行全局代码" tabindex="-1"><a class="header-anchor" href="#执行全局代码" aria-hidden="true">#</a> 执行全局代码</h2><p>在执行全局代码之前，发生以下事情：</p><ol><li>创建作用域链，并包含全局对象</li><li>使用全局对象作为变量对象，将全局范围内声明的变量和函数添加到变量对象中</li><li>将 this 关键字指向全局对象</li></ol><p><img src="'+d+'" alt="执行全局代码之前"></p><p>在准备工作完成后，开始执行全局代码：</p><ol><li>对全局对象的 message 属性赋值</li><li>函数声明 foo() 被跳过，因为函数对象已提前创建</li><li>对全局对象的 num1 和 num2 属性赋值</li><li>计算 num1 和 num2 的和，将结果赋值给 result</li><li>调用全局对象的 console 属性的 log 方法输出结果</li><li>调用全局对象的 foo 属性，执行 foo 函数</li></ol><p><img src="'+k+`" alt="全局代码执行"></p><h2 id="函数代码的执行" tabindex="-1"><a class="header-anchor" href="#函数代码的执行" aria-hidden="true">#</a> 函数代码的执行</h2><p>在执行过程中，如果遇到函数调用，会为函数创建新的函数执行上下文（Function Execution Context，简称 FEC），并将其压入执行上下文栈的栈顶。</p><p>函数执行上下文的变量对象是活动对象（AO），包含函数参数和在函数体中声明的变量和函数。</p><p>现在，我们再来看一下代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Foo message&#39;</span>
  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token keyword">var</span> height <span class="token operator">=</span> <span class="token number">180</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在调用 foo 函数之前，发生以下事情：</p><p><img src="`+v+`" alt="foo函数代码执行之前"></p><p>函数执行时，首先给 message、age、height 赋值，然后执行 console.log(&quot;foo function&quot;);，最后将函数执行上下文从执行上下文栈中弹出。</p><p>执行上下文弹出后，大多数情况下与其关联的变量对象都会被销毁，但全局执行上下文的变量对象会一直存在，直到程序退出，比如关闭网页或浏览器。</p><h2 id="函数中调用了另一个函数" tabindex="-1"><a class="header-anchor" href="#函数中调用了另一个函数" aria-hidden="true">#</a> 函数中调用了另一个函数</h2><p>有时会遇到函数中调用了另一个函数的情况，比如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;foo function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;bar function&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们来看一下这段代码的执行过程：</p><ol><li>创建全局执行上下文，将其压入执行上下文栈的栈顶，关联的全局对象中提前创建了 foo 和 bar 函数对象</li><li>执行全局代码，调用 foo 函数</li><li>创建 foo 函数执行上下文和它关联的 AO，将上下文压入执行上下文栈的栈顶</li><li>执行 foo 函数，调用 bar 函数</li><li>创建 bar 函数执行上下文和它关联的 AO，将上下文压入执行上下文栈的栈顶</li><li>执行 bar 函数，输出 &quot;bar function&quot;</li><li>弹出 bar 函数执行上下文</li><li>继续执行 foo 函数，输出 &quot;foo function&quot;</li><li>弹出 foo 函数执行上下文</li><li>弹出全局执行上下文</li></ol><p><img src="`+m+`" alt="函数中调用了另一个函数"></p><h2 id="作用域-scope-和作用域链-scope-chain" tabindex="-1"><a class="header-anchor" href="#作用域-scope-和作用域链-scope-chain" aria-hidden="true">#</a> 作用域（Scope）和作用域链（Scope Chain）</h2><p>每当创建一个新的执行上下文时，除了关联一个变量对象，还会创建并关联一个作用域链（Scope Chain），并根据程序员编写的代码，为作用域链添加一系列的对象。</p><p>其实作用域链就是一个列表，里面装了一些对象。</p><p>比较正式的说法是：作用域指的是变量和函数的可访问范围，作用域链指的是变量和函数的查找规则。</p><p>假设有如下代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Foo message&#39;</span>

  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Bar message&#39;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码中有三个作用域：</p><ul><li>全局作用域，包含了全局变量 message、函数 foo 和 bar</li><li>foo 函数作用域，包含了变量 message 和函数 bar</li><li>bar 函数作用域，包含了变量 message</li></ul><p>全局的 bar 变量的值是函数 foo 执行之后的返回值，也就是函数 bar。当全局的 bar 变量被调用时，会执行声明在函数 foo 中的函数 bar，它要打印一个 message 变量。</p><p>那么它会如何查找呢？</p><p>它会先在当前的作用域查找 message，如果找到了就使用它，如果没有找到就继续向上一级作用域查找，直到找到全局作用域为止。</p><p>这种查找的方式就像顺着一条链条向上查找，所以叫做作用域链。</p><p>内层作用域可以访问外层作用域的变量和函数，但外层作用域不能访问内层作用域的变量和函数。</p><h2 id="全局代码中的作用域链" tabindex="-1"><a class="header-anchor" href="#全局代码中的作用域链" aria-hidden="true">#</a> 全局代码中的作用域链</h2><p>来看一段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的执行流程如下：</p><ol><li>创建全局执行上下文，将其压入执行上下文栈的栈顶，关联的全局对象中提前创建了 message 变量，但尚未赋值，提前创建了 foo 函数对象，同时也创建并关联了全局作用域链，作用域链中包含了全局对象</li><li>执行全局代码，第一次调用 console.log(message)，开始在作用域链中查找 message 变量，作用域链中只有一个对象，即全局对象，找到了 message 变量，但尚未赋值，控制台输出 undefined</li><li>继续执行全局代码，为 message 赋值，将其值改为&quot;Global message&quot;</li><li>继续执行全局代码，第二次调用 console.log(message)，开始在作用域链中查找 message 变量，作用域链中只有一个对象，即全局对象，找到了 message 变量，其值为&quot;Global message&quot;，控制台输出&quot;Global message&quot;</li><li>弹出全局执行上下文</li></ol><h2 id="函数中的作用域链" tabindex="-1"><a class="header-anchor" href="#函数中的作用域链" aria-hidden="true">#</a> 函数中的作用域链</h2><p>来看一段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

<span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>

  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Foo message&#39;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的执行流程如下：</p><ol><li>创建全局执行上下文，将其压入执行上下文栈的栈顶，关联的全局对象中提前创建了 message 变量，但尚未赋值，提前创建了 foo 函数对象，同时也创建并关联了全局作用域链，作用域链中包含了全局对象</li><li>执行全局代码，第一次调用 console.log(message)，开始在作用域链中查找 message 变量，作用域链中只有一个对象，即全局对象，找到了 message 变量，但尚未赋值，控制台输出 undefined</li><li>继续执行全局代码，为 message 赋值，将其值改为&quot;Global message&quot;</li><li>继续执行全局代码，调用 foo 函数</li><li>创建 foo 函数执行上下文，将其压入执行上下文栈的栈顶，关联的变量对象中提前创建了 message 变量，但尚未赋值，创建并关联了 foo 函数作用域链，作用域链中包含了 foo 函数的 AO 对象和全局对象</li><li>执行 foo 函数，第一次调用 console.log(message)，开始在作用域链中查找 message 变量，作用域链中有两个对象，即 foo 函数的 AO 对象和全局对象，先在自己的 AO 对象中查找，虽然 message 变量没有赋值（值为 undefined），但确实找到了 message 变量，控制台输出 undefined</li><li>继续执行 foo 函数，为 message 赋值，将其值改为&quot;Foo message&quot;</li><li>继续执行 foo 函数，第二次调用 console.log(message)，开始在作用域链中查找 message 变量，作用域链中有两个对象，即 foo 函数的 AO 对象和全局对象，先在自己的 AO 对象中查找，找到了 message 变量，其值为&quot;Foo message&quot;，控制台输出&quot;Foo message&quot;</li><li>弹出 foo 函数执行上下文</li><li>弹出全局执行上下文</li></ol><h2 id="作用域和作用域链的特点" tabindex="-1"><a class="header-anchor" href="#作用域和作用域链的特点" aria-hidden="true">#</a> 作用域和作用域链的特点</h2><p>作用域和作用域链，在它对应的代码被解析时，就已经确定了，不会再改变。</p><p>它们和 this 不同，this 是在函数调用时才确定的，而作用域和作用域链是在函数定义时就确定了，讲白了就是编写代码的时候就确定了。</p><p>来看一段代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Global message&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&#39;Object message&#39;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&#39;Foo message&#39;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先说结果：两次打印的都是&quot;Global message&quot;。</p><p>原因就是全局代码中声明的函数 foo，它的函数对象被创建时（注意不是函数调用时，而是在这之前的 js 引擎解析代码时），函数对象中就已经包含了作用域链，作用域链中包含了全局对象。</p><p>上面的函数 foo 真正执行时，想要打印 message 变量，首先会在自己的 AO 对象里面查找，发现并没有，然后会顺着作用域链向上查找，它的作用域链中只有一个对象，即全局对象，在全局对象中找到了 message 变量，其值为&quot;Global message&quot;，所以打印的就是&quot;Global message&quot;。</p><p>代码执行之前的图：</p><p><img src="`+b+'" alt="代码执行之前的图："></p><p>函数 foo 的作用域链在函数对象创建时就已经确定了，它的作用域链中只有一个对象，即全局对象。</p><p>这个作用域是可以看见的，在上面声明 foo 函数之前打上一个断点，复制代码到浏览器控制台运行：</p><p><img src="'+g+'" alt=""></p><p>当前正在执行全局代码，全局作用域链中只有一个对象，即全局对象。</p><p><img src="'+f+'" alt=""></p><p>展开全局可以看见代码还没有执行到声明函数 foo 的地方，全局对象中就已经有了函数 foo 的函数对象了</p><p>并且函数对象中，已经确定了函数的作用域链，作用域链中只有一个对象，即全局对象。</p><p>当 foo 函数执行时，可以看见它自己的作用域。</p><p><img src="'+h+'" alt=""></p><p>如果 foo 函数中有变量声明的话，可以看见它的 AO 对象中有这个变量，可以看见，声明 age 变量的代码还没执行，age 就已经在 AO 对象中了。</p><p><img src="'+w+'" alt=""></p><p>当 age 变量的赋值代码执行之后，age 的值就变成了 23。</p><p><img src="'+_+'" alt=""></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>JavaScript 引擎管理着一个执行上下文栈（ECS），也叫做代码的调用栈</li><li>每当执行一段代码时，都会创建一个新的执行上下文，并将其压入执行上下文栈的栈顶</li><li>全局代码执行时，会创建全局执行上下文，并将其压入执行上下文栈的栈顶</li><li>函数执行时，会创建新的函数执行上下文，并将其压入执行上下文栈的栈顶</li><li>函数执行上下文的变量对象是活动对象（AO），包含函数参数和在函数体中声明的变量和函数</li><li>全局执行上下文的变量对象是全局对象（GO），包含全局范围内声明的变量和函数</li><li>每个执行上下文关联一个作用域链，用于在当前执行上下文中查找变量和函数</li><li>作用域链是一个列表，里面装了一些对象</li><li>作用域指的是变量和函数的可访问范围，作用域链指的是变量和函数的查找规则</li><li>作用域和作用域链，在它对应的代码被解析时，就已经确定了，不会再改变</li><li>函数对象在创建时，就已经确定了作用域链</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2><p>笔记参考了 ECMAScript 1999 PDF，你可以在 DPF 中查看更多内容。</p>',93),j={href:"https://www.ecma-international.org/wp-content/uploads/ECMA-262_3rd_edition_december_1999.pdf",target:"_blank",rel:"noopener noreferrer"},q=n("h2",{id:"评论区",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#评论区","aria-hidden":"true"},"#"),e(" 评论区")],-1);function O(S,G){const o=s("ExternalLinkIcon"),p=s("CommentService");return t(),l("div",null,[y,n("p",null,[n("a",j,[e("ECMAScript 1999 PDF"),a(o)])]),q,a(p)])}const C=i(x,[["render",O],["__file","index.html.vue"]]);export{C as default};
