import{_ as a,r as p,o as t,c as e,f as o,d as i,e as c,a as n,b as l}from"./app-1bbcc8ed.js";const u="/blog-website/assets/image-20230919213252239-241bd787.png",r="/blog-website/assets/image-20230919215544423-9abb963a.png",d="/blog-website/assets/image-20230919221440494-304bf19d.png",k="/blog-website/assets/image-20230920202533569-49b6c8d5.png",m="/blog-website/assets/image-20230920205214108-551818bf.png",g="data:image/png;base64,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",v="/blog-website/assets/image-20230920210520198-7754fc86.png",h="/blog-website/assets/image-20230927113921615-ef5d45fa.png",b="/blog-website/assets/image-20230927114301190-df94d5e4.png",f={},A=c('<h1 id="浏览器的事件循环" tabindex="-1"><a class="header-anchor" href="#浏览器的事件循环" aria-hidden="true">#</a> 浏览器的事件循环</h1><p>事件循循环是浏览器核心设计的精髓，它的出现大幅度提高了单线程渲染网页的效率。在这篇文章中，我们将深入介绍事件循环的基本原理，帮助你更好地理解浏览器内部运行机制。</p><h2 id="浏览器的进程模型" tabindex="-1"><a class="header-anchor" href="#浏览器的进程模型" aria-hidden="true">#</a> 浏览器的进程模型</h2><p>要彻底理解事件循环，首先需要对浏览器的进程模型有一个基本了解。</p><h3 id="什么是进程" tabindex="-1"><a class="header-anchor" href="#什么是进程" aria-hidden="true">#</a> 什么是进程？</h3><p>在操作系统中运行的每个程序都需要分配一块专用的内存空间，用于存储程序执行时生成的变量、函数以及其他数据。这块内存空间可以被视为一个进程。</p><p><img src="'+u+'" alt="不同应用程序的进程"></p><p>比如淘宝、微信、QQ、浏览器等等，每一个都代表一个进程。</p><p>不同程序拥有不同的内存空间（进程），它们之间是相互独立的，不同进程的内存空间是不会交叉的。</p><p>这种独立性的好处在于，当一个进程崩溃时，它不会影响其他进程的运行。举例来说，如果微信崩溃了，QQ 仍然可以正常使用。</p><p>尽管进程之间可以相互通信，但这需要双方的同意和协作。</p><p>一个程序在运行时至少会有一个进程，这一点很容易理解，因为程序必须运行，而无论它需要多少内存，都需要一块内存空间来支持其执行。</p><h3 id="什么是线程" tabindex="-1"><a class="header-anchor" href="#什么是线程" aria-hidden="true">#</a> 什么是线程？</h3><p>我们可以将内存看作进程，有了进程，可以准备运行程序的代码，但是谁来实际执行这些代码呢？</p><p>系统内存是非常宝贵的，如果系统为程序分配了内存，但程序不运行，系统会终止该程序，回收内存，并将其分配给其他程序。</p><p>执行代码的“执行者”被称为线程。每个程序至少需要一个线程来执行代码，因此每个进程至少有一个线程。</p><p>一旦进程启动，就会自动创建一个线程来执行代码，这个线程被称为主线程。</p><p>当主线程繁忙无法胜任时，进程可以创建其他线程来协助主线程执行代码。这可以类比为一个人忙不过来，便可以寻找其他人来帮忙。</p><p>例如，一个游戏程序可以有多个线程，用于渲染画面、处理用户输入、检查作弊行为等等。</p><p><img src="'+r+'" alt="进程中的多线程"></p><p>这些线程协同工作，以提供出色的用户体验。</p><p>浏览器的事件循环也是建立在这一模型之上，确保网页的平稳运行，而不会阻塞用户界面。了解这一背后的原理将有助于更好地理解浏览器行为。</p><h3 id="浏览器有哪些进程和线程" tabindex="-1"><a class="header-anchor" href="#浏览器有哪些进程和线程" aria-hidden="true">#</a> 浏览器有哪些进程和线程</h3><p>浏览器是一个多进程、多线程的应用程序。</p><p>浏览器的复杂成都远远超过了我们的想象，它不仅仅是一个渲染网页的工具，它还有很多其他的功能，比如下载、打印、浏览历史、收藏夹、浏览器扩展等等。</p><p>为了让浏览器运行更加的稳定，浏览器运行时会启动多个进程，当一个进程崩溃时，浏览器仍然能正常使用。</p><p>我们可以在浏览器的任务管理器中看到浏览器的进程，打开任务管理器的快捷键是 <code>shift + esc</code>。</p><p><img src="'+d+'" alt="浏览器的任务管理器"></p><p>可以看见浏览器有很多进程，每个进程都有自己的功能，我们主要关注进程有三个：</p><p><strong>浏览器进程</strong></p><p>浏览器进程中，有专门的线程，分别负责：</p><ul><li>浏览器界面的渲染展示，注意不是网页渲染，而是浏览器的界面，比如地址栏、书签栏、后退前进按钮等等。</li><li>监听用户的交互，比如用户鼠标的点击、键盘的输入等等。</li></ul><p>浏览器进程还会管理子进程。浏览器程序刚开始运行时，只有一个浏览器进程，网络进程、渲染进程等其他进程都是由浏览器进程创建的。</p><p><strong>网络进程</strong></p><p>网络进程负责加载网络资源，进程内部会启动多个线程来负责不同的网络任务，加载不同的资源。</p><p><strong>渲染进程</strong></p><p>渲染进程启动后，会开启一个渲染主线程，主线程负责解析 HTML、CSS，执行 JS、渲染页面。一般情况下，浏览器会为每个标签页创建一个新的渲染进程，让不同的标签页互不影响。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>浏览器的这种渲染进程的模式，在未来可能会发生改变，Chrome 浏览器计划将同一个网站的标签页放在同一个渲染进程中，这样可以减少内存的占用。</p></div><p>我们马上会重点学习渲染主线程当中的一些细节，比如事件循环。</p><h2 id="渲染主线程是怎么工作的" tabindex="-1"><a class="header-anchor" href="#渲染主线程是怎么工作的" aria-hidden="true">#</a> 渲染主线程是怎么工作的</h2><p>渲染主线程是浏览器中最繁忙的“工作者”，其职责包括但不限于：</p><ul><li>解析 HTML 和 CSS 代码</li><li>执行全局 JavaScript 代码</li><li>计算页面样式和布局信息，构建渲染树，并进行页面绘制</li><li>执行事件处理函数</li><li>处理定时器回调函数</li><li>每秒至少刷新屏幕 60 次（与屏幕刷新率相关）</li><li>...</li></ul><p>既然渲染主线程这么忙，为什么不多创建一些线程来帮忙呢？这个问题后续会讨论。</p><p>渲染主线程会处理很多的任务，但有时会遇到特殊的情况，比如：</p><ul><li><p>正在执行一个耗时的任务，比如 <code>for</code> 循环，循环了一半，用户点击了一个按钮，需要执行一个事件处理函数。这时，渲染主线程应该继续执行循环，循环执行完毕后再执行事件处理函数，还是应该立即执行事件处理函数呢？</p></li><li><p>正在执行一个耗时的任务，比如 <code>for</code> 循环，循环了一半，某个定时器到时间了，需要执行一个回调函数。这时，渲染主线程应该执行谁呢？</p></li><li><p>用户点击了一个按钮，需要执行一个事件处理函数，但同时又有一个定时器到时间了，需要执行一个回调函数。这时，渲染主线程应该执行谁呢？</p></li></ul><p>类似的问题还有很多，这些问题都可以归结为一个问题：渲染主线程应该怎么处理任务的执行顺序？</p><p>渲染主线程的解决方法就是：将任务排好队，按照特定的顺序执行。</p><h3 id="什么是事件循环" tabindex="-1"><a class="header-anchor" href="#什么是事件循环" aria-hidden="true">#</a> 什么是事件循环</h3><p>代码在执行的过程中，会遇到一些无法立即处理的任务，比如：</p><ol><li><p>网络请求，需要等待服务器返回数据后，再执行处理数据的任务，请求可能会花费很长的时间</p></li><li><p>计时器任务，比如 setTimeout、setInterval，需要等待一定的时间后，再执行回调函数</p></li><li><p>用户交互事件，比如点击按钮，需要等待用户点击后，再执行事件处理函数</p></li></ol><p>如果在发请求时，熏染主线程一直等着服务器返回数据，等请求回来，主线程才开始执行数据处理函数，然后再继续往下执行其他代码，这就叫做同步。</p><p>同步的模式，在执行时非常耗时，但代码看起来会非常好理解，因为是一条线拉通的，顺序是从上往下的，编写和阅读都挺爽。</p><p>但是，渲染主线程不可能等待这种任务完成之后，再继续往下执行，这样会使渲染主线程一直处于阻塞状态，导致浏览器网页卡顿，甚至卡死。</p><p>那么熏染主线程应该怎么处理这种情况呢？</p><p>举个例子：</p><p>我（餐厅服务员），我的职责是协助客人点菜以及将厨师做好的菜品送到客人桌前。</p><p>此时，来了第一桌客人点菜，我会将菜单交给厨师，并让他开始准备菜品。我不会在窗口等待厨师完成菜品，因为这样效率较低。</p><p>在等待厨师制作菜品的过程中，我会继续接待第二桌、第三桌的客人点菜，并将他们的菜单交给厨师。同时，厨师正在忙碌地制作菜品。</p><p>当厨师完成菜品后，他不会立即通知我，而是将菜品放置在出餐窗口。虽然厨师未必会按照点菜的顺序制作菜品，但他会把最新完成的菜品放在出餐口的最后。</p><p>当我暂时没有其他客人需要点菜时，我会去出餐窗口查看是否有厨师做好的菜品。如果有，我会将菜品端到相应的客人桌前。</p><p>下面来看个图：</p><p><img src="'+k+'" alt="渲染主线程和事件队列"></p><p>解释上面的图：</p><p>当渲染主线程启动时，会进入一个无限循环，具体代码见 chromium 源码<code>base\\message_loop\\message_pump_default.cc</code></p><p><img src="'+m+'" alt="message_pump_default.cc"></p><p>上面的代码是 C++ ，在 js 中 <code>for(;;)</code> 同样可以无限循环，代码如下：</p><p><img src="'+g+'" alt="在浏览器控制台执行for(;;)"></p><p>渲染主线程的每一次循环，都会检查消息队列中是否有任务，如果有，就取第一个任务执行，执行完成之后，主线程会进入下一次循环，chromium 源码位置在<code>base\\message_loop\\message_pump_default.cc</code> 第 40 行：</p><p><img src="'+v+`" alt="image-20230920210520198"></p><p>如果没有待执行的任务，主线程会进入休眠状态。</p><p>其他所有的线程（包括其他进程的线程），可以随时向消息队列中添加任务。比如“浏览器进程”中监听用户操作的线程，监听到了用户点击某个按钮，需要执行一个事件处理函数，那么监听用户操作的这个线程就会将这个事件处理函数包装为一个“任务”，添加到消息队列中。</p><p>新任务会追加到队列的末尾。如果主线程正在休眠，主线程会被唤醒，开始执行新的任务。</p><p>以上的整个过程，就是“事件循环”（消息循环）。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>“事件循环”是 W3C 文档中的说法，chromium 源代码中叫做“消息循环”，两个称呼指的是同一个东西</p></div><h3 id="什么是异步" tabindex="-1"><a class="header-anchor" href="#什么是异步" aria-hidden="true">#</a> 什么是异步</h3><p>JS 运行在浏览器的渲染进程的渲染主线程中，在一个渲染进程中，渲染主线程是唯一的，所以 JS 是单线程的。</p><p>渲染主线程负责了很多事情，渲染页面，执行 JS 代码等。</p><p>如果使用同步的方式执行代码，渲染主线程很可能会被阻塞，例如在获取数据的网络请求回来之前，代码不会再往下执行，网页上可能是空白的，给用户一种页面卡死的感觉，用户体验很差。</p><p>所以，浏览器采用了异步的方式来执行代码，避免渲染主线程的阻塞。</p><p>异步的具体做法是，当某些耗时任务发生时，如计时器、网络请求、事件监听等，渲染主线程不会等待这些任务的完成，而是将任务交给其他线程去处理，自身立即结束任务的执行，继续执行后面的代码。</p><p>当其他线程完成任务之后，会将事先传递的回调函数包装为任务，加入到消息队列的末尾，等待渲染主线程下一次循环时执行。</p><p>在这种异步的模式下，渲染主线程不会被阻塞，最大限度的保证了单线程的执行效率，也保证了用户体验。</p><h3 id="js-为什么会阻碍页面渲染" tabindex="-1"><a class="header-anchor" href="#js-为什么会阻碍页面渲染" aria-hidden="true">#</a> JS 为什么会阻碍页面渲染</h3><p>先看一段代码：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>btn<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">const</span> title <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;title&#39;</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;btn&#39;</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">duration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">&lt;</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    title<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">&#39;你好&#39;</span>
    <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我在网页中点击 Click 时，页面会卡死 3 秒钟，3 秒钟之后，页面才会显示“你好”。这其实就是 js 阻塞了页面的渲染。</p><p>现在我们来看看原因，当用户点击 Click 按钮时，js 会将 title 的 textContent 设置为“你好”（注意，此处的 title 是一个 dom 对象，修改了它的内容并不会立即在网页上体现，而是需要新的绘制），这一步就会产生一个新的“渲染”任务，这个任务会被添加到消息队列中。</p><p>然后主线程会继续执行 <code>delay(3000)</code>，这是一个死循环，渲染主线程在 3 秒钟内一直死循环，被困在这里。</p><p>当渲染主线程执行完了死循环之后，空闲了，就会去消息队列中取任务，取到了“渲染”任务，就会执行这个任务，在网页中将 title 的内容修改为“你好”。</p><p>所以，js 阻塞了页面的渲染，也可以说是 js 执行时，“渲染”任务被阻塞了。</p><h3 id="消息队列中的任务存在优先级关系吗" tabindex="-1"><a class="header-anchor" href="#消息队列中的任务存在优先级关系吗" aria-hidden="true">#</a> 消息队列中的任务存在优先级关系吗</h3><p>单个的任务之间没有优先级，在同一个消息队列中，先进先出。</p><p>但是不同的消息队列之间是存在优先级关系的。</p><p>根据 W3C 的最新解释：</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行</li></ul><p>https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</p><p>浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法，前端圈子中曾经流行的“宏任务”和“微任务”说法也不再适合解释新的浏览器行为。</p><p>在目前 Chrome 的实现中，至少包含了以下几种队列：</p><ul><li>延时队列：存放计时器到点后的回调函数任务，优先级【中】</li><li>交互队列：存放用户操作后产生的事件处理任务，优先级【高】</li><li>微队列：存放需要最快执行的任务，优先级【最高】</li></ul><p>看下 chromium 的源代码，代码在 <code>third_party\\blink\\public\\platform\\task_type.h</code>：</p><p><img src="`+h+'" alt="image-20230927113921615"></p><p><code>TaskType</code> 中的每个字段都是一种任务类型，总共有超过 80 种任务类型。</p><p>注意，“任务类型”并不等于“任务队列”，有一些不同的任务类型可能会被放在同一个队列中。W3C 除了规定浏览器必须有一个微队列之外，并没有限制浏览器厂商去实现其他的队列。</p><p>下面三个是用于处理计时器任务类型，可以发现任务类型分的非常仔细。</p><p><img src="'+b+`" alt="image-20230927114301190"></p><p>还有跟用户交互相关的：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// third_party\\blink\\public\\platform\\task_type.h:46
kUserInteraction = 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以及和网络任务相关的：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>// third_party\\blink\\public\\platform\\task_type.h:50
kNetworking = 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>微队列的优先级是最高的，甚至高于存放绘制任务的队列。</p><p>W3C 在 https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint 中的解释（意译）：</p><p>当事件循环的微任务队列不为空时，让一个变量的值等于微任务队列中的第一个，然后执行这个变量的值。</p><p>添加任务到微队列的方式，主要是 Promise、MutationObserver</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 立即将一个函数添加到微任务队列</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;promise&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>笔试有时会考察你对事件循环的掌握程度，比如下面的题目：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案是：4，1, 2, 3</p><p>代码的执行顺序是：</p><ol><li>foo 的函数定义，略过，主线程继续往下</li><li>setTimeout 交给计时器线程，主线程继续往下（计时器线程会将打印 3 的回调函数添加到计时器任务队列中）</li><li>立即添加函数 foo 到微任务队列中，主线程继续往下</li><li>打印 4，主线程的任务执行完毕，开始下一轮循环</li><li>发现微任务队列中有任务，立即执行，打印 1，并且将打印 2 的任务添加到微任务队列中，本次循环结束</li><li>开始下一轮循环，发现微任务队列中有任务，立即执行，打印 2，本次循环结束</li><li>开始下一轮循环，发现计时器任务队列中有任务，立即执行，打印 3</li></ol>`,120),C=n("h2",{id:"评论区",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#评论区","aria-hidden":"true"},"#"),l(" 评论区")],-1);function J(E,w){const s=p("CommentService");return t(),e("div",null,[A,o(`

### 描述 js 的事件循环

事件循环也叫做消息循环，是浏览器渲染进程的渲染主线程的工作方式。

在 chromium 的源代码中，主线程启动后，会开启一个不会结束的 for 循环，每次循环都会从消息队列中取出第一个任务执行（如果队列中有任务的话），而其他线程，只需要在合适的时候将任务加入到消息队列末尾即可。

过去将消息队列简单的分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在一个队列中，不同的任务可以属于不同的队列。

不同的任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。

浏览器必须有一个微队列，微队列拥有最高优先级，必须优先调度执行。

### js 中的计时器能做到精确计时吗？原因是什么

答案是不行。原因如下：

1. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此不能保证回调函数一定会在规定时间内执行。

2. 按照 W3C 的标准，浏览器实现计时器时，如果计时器的嵌套超过了 5 层，则从第 6 层开始，会带有 4 毫秒的最少时间（setTimeout 的第二个参数），当代码编写的计时时间小于 4 毫秒时，又会有偏差，具体代码参见 chromium 源码\`third_party\\blink\\renderer\\modules\\scheduler\\dom_timer.cc\` 第 60 行。

3. js 的计时器最终调用的还是操作系统的方法，操作系统的计时方法也不是完全精确的。

4. 从硬件上看，计算机的硬件组成中，没有包含原子钟，所以计算机本身就不具备精确计时的能力。 `),C,i(s)])}const I=a(f,[["render",J],["__file","index.html.vue"]]);export{I as default};
